using System;
using System.Collections.Generic;
using System.Text;

using EM.Collections;
using ORM.exceptions;
//using ORM.render;
//using ORM.render.RenderControls;


namespace ORM.DBFields
{
    [Serializable]
    public abstract class GenericField
    {
        public string name {get; set;}
        protected internal Object _value;   //alow to set field at data retreivel form DB Table
        public Object oldValue { get; set; }          //saves the value before updating to a new one so that the SQL update can do a where
        
        /// <summary>
        /// if oldValue is DBNull then return NULL otherwise just return oldValue
        /// </summary>
        public Object oldValueSafe 
        {
            get 
            {
                return (oldValue == DBNull.Value) ? null : oldValue; 
            }
        }
        
        /// <summary>
        /// used internaly when parsing from string to actual value type - Int32, Int16, Byte, String, DateTime etc 
        /// </summary>
        public string valueTypeName { get; set; }     //Int32, Int16, Byte, String, DateTime etc
        
        /// <summary>
        ///  <br>- usualy set when the class is generated by inspecting the database</br>
        ///  <br>- has priority over this.defaultValue in insert/update methods of TableRowDynamicSQL</br> 
        ///  <br>- not used by TableRowStoredProcBased</br>
        /// </summary>
        public bool hasDefaultConstraint { get; set; }

        /// <summary>
        /// - see hasDefaultConstraint 
        /// - used when updating from an old non default value to a null then will not send null 
        ///   if the field is required but it will send this.defaultValue instead
        /// </summary>
        public Object defaultValue { get; set; }  //

        /// <summary>
        /// get/set - when doing validate() could throw ValidationExeption 
        /// <br>- usualy set when the class is generated by inspecting the database</br>
        /// </summary>
        public bool allowNull { get; set; }

        /// <summary>
        /// get/set  
        /// <br>- usualy set when the class is generated by inspecting the database</br>
        /// <br>- is not sent to insert/update and is auto populated after insert if is PK (only if PK) </br>
        /// </summary>
        public bool isIdentity { get; set; }      //identity field


        public TableRow table { get; set; }

        /// <summary>
        /// - will not be sent to insert/update methods
        /// <br>- usualy set when the class is generated by inspecting the database</br>
        /// <br>- wtill trow ValidationError if it's value is attemptet to be set</br>
        /// </summary>        
        public bool isComputed { get; set; } 

        /// <summary>
        /// list of errors returned by validate() method
        /// </summary>
        public EList<ValidationException> validationErrors { get; set; }
        public delegate bool ValidatorFunc(GenericField fld);

        /// <summary>
        /// - list of delegates of type ValidatorFunc 
        /// - user may pass in custom validations 
        /// </summary>
        public EList<ValidatorFunc> validators { get; set; }      //custom validators

        public delegate void ValueSet(GenericField fld);
        /// <summary>
        /// - event called when this.value is being updated 
        /// </summary>
        public event ValueSet OnValueSet;

        public GenericField() { }
        public GenericField(string name, bool allowNull) : this(name, allowNull, null, false) { }
        public GenericField(string name, bool allowNull, bool hasDefaultConstraint) : this(name, allowNull, null, hasDefaultConstraint) { }
        public GenericField(string name, bool allowNull, Object value) : this(name, allowNull, value, false) { }
        public GenericField(string name, bool allowNull, Object value, bool hasDefaultConstraint) 
        {
            this.name = name;
            this.allowNull = allowNull;
            this.isComputed = false;
            this.value = value;
            this.isIdentity = false;
            this.validationErrors = new EList<ValidationException>();
            //this.renderAttributes = new RenderAttributes();
            //this.renderControl = null;
            this.validators = new EList<ValidatorFunc>();
            this.hasDefaultConstraint = hasDefaultConstraint;            
        }

        public virtual Object value
        {
            get  
            {
                if (this._value == System.DBNull.Value) { this._value = null; }
                return this._value; 
            }
            set 
            {
                if (this.isComputed)
                {
                    ValidationException ve = new ValidationException("This is a computed field and it's value can not be set");
                    ve.fieldName = this.name;
                    validationErrors.Add(ve);
                    throw ve;
                }
                this._value = value;
                if (OnValueSet != null)
                {
                    this.OnValueSet(this);
                }
            }
        }

        public abstract Object parseStringToValue(string val);

        /// <summary>
        /// compute if the field is required 
        /// </summary>
        public bool isRequired
        {
            get
            {
                return !this.allowNull && !this.hasDefaultConstraint && !this.isComputed && this.defaultValue == null && !this.isIdentity;
            }
        }

        protected virtual bool mainValidate() 
        {
            if (this.value == null && this.isRequired)
            {
                ValidationException ve = new ValidationException("This is a required field");
                ve.fieldName=this.name;
                validationErrors.Add(ve);
                return false;
            }
            return true;
        }

        public virtual bool validate()
        {
            bool res = this.mainValidate();
            if (!res) { return false; }  //don't run custom validators if main did't validate

            foreach (ValidatorFunc v in this.validators)
            {
                //if v() is to fail, it should add a new ValidationException to the list of exceptions and return false
                res = v(this) && res;
            }
            return res;
        }


        ///// <summary>
        ///// render using current field render attributes
        ///// </summary>
        //public virtual Object render() { return this.render(new RenderAttributes()); }
        ///// <summary>
        ///// - same as render(RenderAttributes.fromStr(atrDictLiteral))
        ///// </summary>
        //public virtual Object render(string atrDictLiteral) { return this.render(RenderAttributes.fromStr(atrDictLiteral)); }
        ///// <summary>
        ///// render using current field render attributes (this.renderAttributes) combined with custom given renderAttributes
        ///// </summary>
        //public virtual Object render(RenderAttributes renderAttribs)
        //{
        //    return this.renderControl.render(renderAttribs);
        //}
        
        
    }


}



